#! /usr/bin/perl -w
#
# labl: main labl script

use strict;
use warnings;
use v5.14;
use Cwd qw(getcwd abs_path);

our $root_dir;
our $cwd;

sub do_help {
    print <<EOT
usage:
    labl COMMAND [LABEL] files

    labl is a tool to manage labels on files

    Valid commands include:
    help                print this help text
    list                list all existing labels
    show FILES          show labels associated with each file
    rm FILES            rm FILES, fix labels
    mv FILES DEST       mv FILES to DEST which must be a dir, fix labels
    mv SRC DEST         rename SRC to DEST, fix labels
    add LABEL FILES     add LABEL to FILES
    drop LABEL FILES    drop LABEL from FILES
    grep LABEL FILES    filter FILES down to those labeled with LABEL
EOT
}

sub all_labels {
    my @labels;
    opendir(my $dh, "$root_dir/.labl") or
	die "Can't opendir $root_dir/.labl: $!";
    while (readdir $dh) {
	push @labels, $_ unless (/^\./);
    }
    closedir $dh;
    return \@labels;
}

sub all_labeled {
    my %links;
    my $label = shift;
    chdir("$root_dir/.labl/$label");
    opendir(my $dh, ".") or
	die "Can't opendir $root_dir/.labl/$label: $!";
    while (readdir $dh) {
	unless (/^\./) {
	    my $link = readlink($_);
	    defined($link) or die "readlink fail: $!";
	    # all links start with "../../"
	    $links{substr($link, 6)} = $_;
	}
    }
    closedir $dh;
    chdir($cwd);
    return \%links;
}

sub do_list {
    my @labels = all_labels();
    foreach (@labels) {
	say $_;
    }
}

# find the project root dir
sub find_root_dir {
    $cwd = getcwd();
    my $found_dir;
    while(1) {
	my $cwd = getcwd();
	if (-d '.labl') {
	    $found_dir = $cwd;
	    last;
	}
	if (-d '.git') {
	    if (mkdir(".labl")) {
		$found_dir = $cwd;
		last;
	    } else {
		last;
	    }
	}
	last unless(chdir(".."));
    }
    chdir($cwd);
    return $found_dir if ($found_dir);
    return 0;
}

# find the relative file name from root of the project
sub rel_name_from_root {
    # root_dir must be a prefix of the name
    my $name = abs_path(shift);
    return substr($name, length($root_dir)+1);
}

sub do_show {
    my %name_map;
    my %name_canon_map;
    my @canons;
    foreach (@_) {
	my $canon_name = rel_name_from_root($_);
	push @canons, $canon_name;
	$name_map{$canon_name} = [];
	$name_canon_map{$_} = $canon_name;
    }
    foreach my $label (@{all_labels()}) {
	my $label_map = all_labeled($label);
	foreach my $canon (@canons) {
	    next unless (exists($label_map->{$canon}));
	    push @{$name_map{$canon}}, $label;
	}
    }
    foreach (@_) {
	my $canon_name = $name_canon_map{$_};
	if (scalar(@{$name_map{$canon_name}})) {
	    my $labels = join(" ",@{$name_map{$canon_name}});
	    say "$_:";
	    say $labels;
	}
    }
}

sub do_rm {
    my @canons = map(rel_name_from_root($_), @_);
    foreach my $label (@{all_labels()}) {
	my $label_map = all_labeled($label);
	foreach my $canon (@canons) {
	    next unless (exists($label_map->{$canon}));
	    unlink("$root_dir/.labl/$label/".$label_map->{$canon}) or
		die "cannot unlink: $!";
	}
    }
    foreach (@_) {
	unlink($_);
    }
}

sub do_mv {
    my $dest = pop;
    my %mv_map;
    # is it a dir
    if (substr($dest, -1) eq "/") {
	foreach (@_) {
	    my $l = rindex($_, "/");
	    my $basename = ($l >= 0) ? substr($_, $l + 1) : $_;
	    $mv_map{$_} = $dest . $basename;
	}
    } else {
	die "mv of more than one file require an dir at last"
	    unless (scalar(@_) == 1);
	$mv_map{shift} = $dest;
    }
    return do_real_mv(\%mv_map);
}

sub do_real_mv {
    my $mv_map = shift;
    my %canon_mv_map;
    foreach (keys(%{$mv_map})) {
	$canon_mv_map{rel_name_from_root($_)} =
	    rel_name_from_root($mv_map->{$_});
	rename($_, $mv_map->{$_}) or
	    die "cannot rename: $!";
    }
    my @canons = keys(%canon_mv_map);
    foreach my $label (@{all_labels()}) {
	my $label_map = all_labeled($label);
	chdir("$root_dir/.labl/$label") or
	    die "cannot chdir: $!";
	foreach my $canon (@canons) {
	    next unless (exists($label_map->{$canon}));
	    unlink($label_map->{$canon});
	    my $new_canon = $canon_mv_map{$canon};
	    my $last_slash = rindex($new_canon, "/");
	    my $basename = ($last_slash >= 0) ?
		substr($new_canon, $last_slash + 1)
		: $new_canon;
	    symlink("../../" . $new_canon, $basename) or
		die "cannot symlink: $!";
	}
	chdir($cwd);
    }
}

sub do_add {
    my $label = shift;
    my @canons = map(rel_name_from_root($_), @_);
    unless (-e "$root_dir/.labl/$label") {
	mkdir "$root_dir/.labl/$label" or
	    die "cannot mkdir: $!";
    }
    chdir("$root_dir/.labl/$label") or
	die "cannot chdir: $!";
    foreach (@canons) {
	my $l = rindex($_, "/");
	my $basename = ($l >= 0) ? substr($_, $l + 1) : $_;
	if (-e $basename) {
	    say STDERR "the file $basename already exist in $root_dir/.labl/$label";
	    next;
	}
	symlink("../../" . $_, $basename) or die "cannot symlink: $!";
    }
    chdir($cwd);
}

sub do_drop {
    my $label = shift;
    my @canons = map(rel_name_from_root($_), @_);
    chdir("$root_dir/.labl/$label") or
	die "cannot chdir: $!";
    foreach (@canons) {
	my $l = rindex($_, "/");
	my $basename = ($l >= 0) ? substr($_, $l + 1) : $_;
	unless (-e $basename) {
	    say STDERR "the file $basename already gone in $root_dir/.labl/$label";
	    next;
	}
	unlink($basename) or
	    die "cannot unlink: $!";
    }
    chdir($cwd);
}

sub do_grep {
    my $label = shift;
    my @canons = map(rel_name_from_root($_), @_);
    chdir("$root_dir/.labl/$label") or
	die "cannot chdir: $!";
    for (my $i = 0; $i < scalar(@_); $i++) {
	my $canon = $canons[$i];
	my $l = rindex($canon, "/");
	my $basename = ($l >= 0) ? substr($canon, $l + 1) : $canon;
	next unless (-e $basename);
	my $link = readlink($basename);
	defined($link) or die "readlink fail: $!";
	if ($link ne ("../../" . $canon)) {
	    say STDERR "the file $basename in $root_dir/.labl/$label is incorrect";
	} else {
	    say $_[$i];
	}
    }
    chdir($cwd);
}

die "Usage: $0 command ...\n" if (scalar(@ARGV)<1);
my $command = shift(@ARGV);

for ($command) {
    # the first 2 commands has no argument
    if ($_ eq "help") {
	do_help();
	last;
    }
    die "Cannot find project root dir" unless (($root_dir = find_root_dir()));
    if ($_ eq "list") {
	do_list();
	last;
    }
    die "Usage: $0 $command files \n" if (scalar(@ARGV)<1);
    # the next 3 commands operate on files only
    if ($_ eq "show") {
	do_show(@ARGV);
	last;
    }
    if ($_ eq "rm") {
	do_rm(@ARGV);
	last;
    }
    if ($_ eq "mv") {
	do_mv(@ARGV);
	last;
    }
    # the next 3 commands operate on a LABEL and files
    my $label = shift(@ARGV);
    die "Usage: $0 $command $label files\n" if (scalar(@ARGV)<1);
    if ($_ eq "add") {
	do_add($label, @ARGV);
	last;
    }
    die "$label is not a valid label\n"
	unless (-d ($root_dir . "/.labl/" . $label));
    if ($_ eq "drop") {
	do_drop($label, @ARGV);
	last;
    }
    if ($_ eq "grep") {
	do_grep($label, @ARGV);
	last;
    }
    die "Unknown command: $command\n";
}
